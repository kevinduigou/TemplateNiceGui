"""GCP Pub/Sub Client for job management.

This module provides a client for interacting with GCP Pub/Sub for async task execution.
It handles message publishing, job status tracking via Firestore, and metadata retrieval.
This layer is allowed to use try/except for I/O operations.
"""

import json
import uuid
from typing import Any

from google.cloud import firestore, pubsub_v1
from result import Err, Ok, Result


class PubSubClient:
    """Client for GCP Pub/Sub job management."""

    def __init__(
        self,
        project_id: str,
        topic_name: str = "async-tasks",
        firestore_collection: str = "job_metadata",
    ):
        """Initialize Pub/Sub client and test connection.

        Args:
            project_id: GCP project ID
            topic_name: Pub/Sub topic name for task messages
            firestore_collection: Firestore collection for job metadata
        """
        self._project_id = project_id
        self._topic_name = topic_name
        self._firestore_collection = firestore_collection
        self._topic_path = f"projects/{project_id}/topics/{topic_name}"
        
        self._publisher: pubsub_v1.PublisherClient | None = None
        self._firestore_client: firestore.Client | None = None
        self._connection_status: str = "not_tested"
        self._connection_error: str | None = None

        # Test connection at startup
        self._test_connection_at_startup()

    def _test_connection_at_startup(self) -> None:
        """Test GCP connection at startup and store status."""
        try:
            # Test Pub/Sub connection
            publisher = pubsub_v1.PublisherClient()
            publisher.get_topic(request={"topic": self._topic_path})
            
            # Test Firestore connection
            firestore_client = firestore.Client(project=self._project_id)
            # Simple read to test connection
            firestore_client.collection(self._firestore_collection).limit(1).get()
            
            self._connection_status = "connected"
            self._connection_error = None
        except Exception as e:
            self._connection_status = "failed"
            self._connection_error = str(e)

    def _ensure_connection(self) -> Result[tuple[pubsub_v1.PublisherClient, firestore.Client], str]:
        """Ensure GCP clients are initialized.

        Returns:
            Ok((publisher, firestore_client)) if successful, Err(str) if failed
        """
        try:
            if self._publisher is None:
                self._publisher = pubsub_v1.PublisherClient()
            if self._firestore_client is None:
                self._firestore_client = firestore.Client(project=self._project_id)
            return Ok((self._publisher, self._firestore_client))
        except Exception as e:
            return Err(f"Failed to connect to GCP: {str(e)}")

    def enqueue_job(
        self,
        func: str,
        *args: Any,
        job_timeout: int | None = None,
        **kwargs: Any
    ) -> Result[str, str]:
        """Enqueue a job for execution by Pub/Sub worker.

        Args:
            func: Full path to the function (e.g., "module.function")
            *args: Positional arguments for the function
            job_timeout: Job timeout in seconds (default: 180s, None for no timeout)
            **kwargs: Keyword arguments for the function

        Returns:
            Ok(job_id) if successful, Err(str) with error message if failed
        """
        clients_result = self._ensure_connection()
        match clients_result:
            case Ok((publisher, firestore_client)):
                try:
                    # Generate unique job ID
                    job_id = str(uuid.uuid4())
                    
                    # Create job metadata in Firestore
                    job_ref = firestore_client.collection(self._firestore_collection).document(job_id)
                    job_ref.set({
                        "job_id": job_id,
                        "function": func,
                        "status": "queued",
                        "created_at": firestore.SERVER_TIMESTAMP,
                        "timeout": job_timeout,
                        "meta": {},
                        "events": [],
                    })
                    
                    # Prepare message payload
                    message_data = {
                        "job_id": job_id,
                        "function": func,
                        "args": args,
                        "kwargs": kwargs,
                        "timeout": job_timeout,
                    }
                    
                    # Publish message to Pub/Sub
                    message_bytes = json.dumps(message_data).encode("utf-8")
                    future = publisher.publish(self._topic_path, message_bytes)
                    future.result()  # Wait for publish to complete
                    
                    return Ok(job_id)
                except Exception as e:
                    return Err(f"Failed to enqueue job: {str(e)}")
            case Err(error):
                return Err(error)

    def get_job_status(self, job_id: str) -> Result[str, str]:
        """Get the status of a job.

        Args:
            job_id: The job ID to check

        Returns:
            Ok(status) with status string, Err(str) if job not found or error
        """
        clients_result = self._ensure_connection()
        match clients_result:
            case Ok((_, firestore_client)):
                try:
                    job_ref = firestore_client.collection(self._firestore_collection).document(job_id)
                    job_doc = job_ref.get()
                    
                    if not job_doc.exists:
                        return Err(f"Job {job_id} not found")
                    
                    job_data = job_doc.to_dict()
                    return Ok(job_data.get("status", "unknown"))
                except Exception as e:
                    return Err(f"Failed to get job status: {str(e)}")
            case Err(error):
                return Err(error)

    def get_job_meta(self, job_id: str) -> Result[dict[str, Any], str]:
        """Get the metadata of a job.

        Args:
            job_id: The job ID to retrieve metadata for

        Returns:
            Ok(metadata_dict) if successful, Err(str) if job not found or error
        """
        clients_result = self._ensure_connection()
        match clients_result:
            case Ok((_, firestore_client)):
                try:
                    job_ref = firestore_client.collection(self._firestore_collection).document(job_id)
                    job_doc = job_ref.get()
                    
                    if not job_doc.exists:
                        return Err(f"Job {job_id} not found")
                    
                    job_data = job_doc.to_dict()
                    return Ok(job_data.get("meta", {}))
                except Exception as e:
                    return Err(f"Failed to get job metadata: {str(e)}")
            case Err(error):
                return Err(error)

    def get_job_result(self, job_id: str) -> Result[Any, str]:
        """Get the result of a completed job.

        Args:
            job_id: The job ID to retrieve result for

        Returns:
            Ok(result) if job is finished, Err(str) if job not found, not finished, or error
        """
        clients_result = self._ensure_connection()
        match clients_result:
            case Ok((_, firestore_client)):
                try:
                    job_ref = firestore_client.collection(self._firestore_collection).document(job_id)
                    job_doc = job_ref.get()
                    
                    if not job_doc.exists:
                        return Err(f"Job {job_id} not found")
                    
                    job_data = job_doc.to_dict()
                    status = job_data.get("status", "unknown")
                    
                    if status != "finished":
                        return Err(f"Job {job_id} is not finished yet (status: {status})")
                    
                    return Ok(job_data.get("result"))
                except Exception as e:
                    return Err(f"Failed to get job result: {str(e)}")
            case Err(error):
                return Err(error)

    def get_connection_status(self) -> str:
        """Get the current connection status.

        Returns:
            Connection status: 'connected', 'failed', or 'not_tested'
        """
        return self._connection_status

    def get_connection_error(self) -> str | None:
        """Get the connection error if any.

        Returns:
            Error message if connection failed, None otherwise
        """
        return self._connection_error

    def test_connection_now(self) -> Result[str, str]:
        """Test GCP connection right now and update status.

        Returns:
            Ok("connected") if successful, Err(error_message) if failed
        """
        try:
            publisher = pubsub_v1.PublisherClient()
            publisher.get_topic(request={"topic": self._topic_path})
            
            firestore_client = firestore.Client(project=self._project_id)
            firestore_client.collection(self._firestore_collection).limit(1).get()
            
            self._connection_status = "connected"
            self._connection_error = None
            return Ok("connected")
        except Exception as e:
            self._connection_status = "failed"
            self._connection_error = str(e)
            return Err(str(e))

    def cancel_job(self, job_id: str) -> Result[None, str]:
        """Cancel a running or queued job.

        Args:
            job_id: The job ID to cancel

        Returns:
            Ok(None) if successful, Err(str) if job not found or error
        """
        clients_result = self._ensure_connection()
        match clients_result:
            case Ok((_, firestore_client)):
                try:
                    job_ref = firestore_client.collection(self._firestore_collection).document(job_id)
                    job_doc = job_ref.get()
                    
                    if not job_doc.exists:
                        return Err(f"Job {job_id} not found")
                    
                    # Update job status to canceled
                    job_ref.update({
                        "status": "canceled",
                        "canceled_at": firestore.SERVER_TIMESTAMP,
                    })
                    
                    return Ok(None)
                except Exception as e:
                    return Err(f"Failed to cancel job: {str(e)}")
            case Err(error):
                return Err(error)

    def get_queue_info(self) -> Result[dict[str, Any], str]:
        """Get information about the Pub/Sub topic and job queue.

        Returns:
            Ok(queue_info) if successful, Err(str) if failed
        """
        clients_result = self._ensure_connection()
        match clients_result:
            case Ok((publisher, firestore_client)):
                try:
                    # Get topic info
                    topic = publisher.get_topic(request={"topic": self._topic_path})
                    
                    # Count jobs by status in Firestore
                    jobs_collection = firestore_client.collection(self._firestore_collection)
                    
                    queued_count = len(list(jobs_collection.where("status", "==", "queued").stream()))
                    running_count = len(list(jobs_collection.where("status", "==", "running").stream()))
                    finished_count = len(list(jobs_collection.where("status", "==", "finished").stream()))
                    failed_count = len(list(jobs_collection.where("status", "==", "failed").stream()))
                    
                    info = {
                        "topic_name": topic.name,
                        "queued_job_count": queued_count,
                        "running_job_count": running_count,
                        "finished_job_count": finished_count,
                        "failed_job_count": failed_count,
                    }
                    return Ok(info)
                except Exception as e:
                    return Err(f"Failed to get queue info: {str(e)}")
            case Err(error):
                return Err(error)
