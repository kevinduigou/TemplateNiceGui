"""Database repository for persistence operations.

This layer is allowed to use try/except for database I/O.
All database operations return Result types for error handling.
"""

import os
from datetime import datetime
from pathlib import Path
from typing import final

from result import Err, Ok, Result
from sqlalchemy import create_engine
from sqlalchemy.orm import Session, sessionmaker

from {{ project_slug }}.infrastructure.cache_db.db_models import Base, ExampleModel, User

# Global database engine and session factory
# Initialized at application startup
_engine = None
_session_factory = None
_database_url = None


def initialize_database(database_url: str | None = None) -> None:
    """Initialize the database engine and session factory at application startup.
    
    This function should be called once when the application starts.
    It handles PostgreSQL URL conversion and creates the database tables.
    
    Args:
        database_url: Database URL. If None, reads from DATABASE_URL env var.
                     Defaults to sqlite:///data/{{ project_slug }}.db if not set.
    """
    global _engine, _session_factory, _database_url
    
    # Get database URL from parameter or environment
    if database_url is None:
        database_url = os.getenv("DATABASE_URL", "sqlite:///data/{{ project_slug }}.db")
    
    # Store the original database URL
    _database_url = database_url
    
    # Convert postgresql:// URLs to postgresql+psycopg:// for psycopg3 compatibility
    if database_url.startswith("postgresql://"):
        database_url = database_url.replace("postgresql://", "postgresql+psycopg://", 1)
    
    # Ensure data directory exists for SQLite
    if database_url.startswith("sqlite:///"):
        db_path = database_url.replace("sqlite:///", "")
        Path(db_path).parent.mkdir(parents=True, exist_ok=True)
    
    # Create engine with connection pooling and health checks
    _engine = create_engine(database_url, pool_pre_ping=True)
    _session_factory = sessionmaker(bind=_engine)
    
    # WARNING: create_all() only creates new tables and does not handle schema migrations.
    # For production use or when modifying existing table schemas, consider implementing
    # Alembic migrations to safely handle:
    # - Adding/removing columns to existing tables
    # - Changing column types or constraints
    # - Data transformations during schema changes
    # Current approach only supports: new table creation and initial database setup.
    Base.metadata.create_all(_engine)


@final
class DatabaseSessionManager:
    """Creates new SQLAlchemy sessions for each request to avoid transaction issues."""

    __slots__ = ()

    @staticmethod
    def get_session() -> Session:
        """Create a new session for each request to avoid transaction conflicts.
        
        Returns:
            A new SQLAlchemy session
            
        Raises:
            RuntimeError: If database has not been initialized
        """
        if _session_factory is None:
            raise RuntimeError(
                "Database not initialized. Call initialize_database() at application startup."
            )
        return _session_factory()


class DBRepository:
    """Repository for database operations.
    
    This class handles all database interactions using SQLAlchemy.
    It follows the infrastructure layer pattern where try/except is allowed.
    """

    def __init__(self) -> None:
        """Initialize database repository.
        
        The database must be initialized via initialize_database() before creating
        a DBRepository instance.
        """
        if _session_factory is None:
            raise RuntimeError(
                "Database not initialized. Call initialize_database() at application startup."
            )

    def get_db_url(self) -> str:
        """Get the database URL that was used to initialize the database.
        
        Returns:
            The database URL string
            
        Raises:
            RuntimeError: If database has not been initialized
        """
        if _database_url is None:
            raise RuntimeError(
                "Database not initialized. Call initialize_database() at application startup."
            )
        return _database_url

    def example_exists(self, example_id: str) -> Result[bool, str]:
        """Check if an example record exists in the database.

        Args:
            example_id: The example ID to check

        Returns:
            Ok(bool) - True if exists, False otherwise
            Err(str) if database error
        """
        try:
            with DatabaseSessionManager.get_session() as session:
                exists = (
                    session.query(ExampleModel)
                    .filter_by(example_id=example_id)
                    .first()
                    is not None
                )
                return Ok(exists)
        except Exception as e:
            return Err(f"Database error: {str(e)}")

    def save_example(
        self, example_id: str, name: str, description: str | None = None
    ) -> Result[None, str]:
        """Save or update an example record.

        Args:
            example_id: Unique identifier for the example
            name: Name of the example
            description: Optional description

        Returns:
            Ok(None) if successful
            Err(str) with error message if failed
        """
        try:
            with DatabaseSessionManager.get_session() as session:
                now = datetime.now()

                # Upsert: update if exists, create if not
                existing = session.get(ExampleModel, example_id)
                if existing:
                    existing.name = name
                    existing.description = description
                    existing.updated_at = now
                else:
                    new_example = ExampleModel(
                        example_id=example_id,
                        name=name,
                        description=description,
                        created_at=now,
                        updated_at=now,
                    )
                    session.add(new_example)

                session.commit()
                return Ok(None)
        except Exception as e:
            return Err(f"Database error: {str(e)}")

    def get_example(self, example_id: str) -> Result[ExampleModel | None, str]:
        """Get an example record by ID.

        Args:
            example_id: The example ID to retrieve

        Returns:
            Ok(ExampleModel | None) - Example model if found, None if not found
            Err(str) if database error
        """
        try:
            with DatabaseSessionManager.get_session() as session:
                model = session.get(ExampleModel, example_id)
                return Ok(model)
        except Exception as e:
            return Err(f"Database error: {str(e)}")

    def list_all_examples(self) -> Result[list[ExampleModel], str]:
        """List all example records from the database.

        Returns:
            Ok(list[ExampleModel]) - List of all example models
            Err(str) if database error
        """
        try:
            with DatabaseSessionManager.get_session() as session:
                models = session.query(ExampleModel).all()
                return Ok(models)
        except Exception as e:
            return Err(f"Database error: {str(e)}")

    def delete_example(self, example_id: str) -> Result[None, str]:
        """Delete an example record by ID.

        Args:
            example_id: The example ID to delete

        Returns:
            Ok(None) if successful
            Err(str) with error message if failed
        """
        try:
            with DatabaseSessionManager.get_session() as session:
                model = session.get(ExampleModel, example_id)
                if model:
                    session.delete(model)
                    session.commit()
                return Ok(None)
        except Exception as e:
            return Err(f"Database error: {str(e)}")

    def save_user(
        self,
        user_id: str,
        email: str,
        oauth_provider: str,
        oauth_sub: str,
        name: str | None = None,
        picture: str | None = None,
    ) -> Result[None, str]:
        """Save or update a user record.

        Args:
            user_id: Unique identifier for the user
            email: User's email address
            oauth_provider: OAuth provider name ('google' or 'twitter')
            oauth_sub: Provider's user ID
            name: User's display name (optional)
            picture: URL to user's profile picture (optional)

        Returns:
            Ok(None) if successful
            Err(str) with error message if failed
        """
        try:
            with DatabaseSessionManager.get_session() as session:
                now = datetime.now()

                # Upsert: update if exists, create if not
                existing = session.get(User, user_id)
                if existing:
                    existing.email = email
                    existing.name = name
                    existing.picture = picture
                    existing.oauth_provider = oauth_provider
                    existing.oauth_sub = oauth_sub
                    existing.last_login_at = now
                else:
                    new_user = User(
                        user_id=user_id,
                        email=email,
                        name=name,
                        picture=picture,
                        oauth_provider=oauth_provider,
                        oauth_sub=oauth_sub,
                        created_at=now,
                        last_login_at=now,
                    )
                    session.add(new_user)

                session.commit()
                return Ok(None)
        except Exception as e:
            return Err(f"Database error: {str(e)}")

    def get_user_by_email(self, email: str) -> Result[User | None, str]:
        """Get a user record by email.

        Args:
            email: The email address to search for

        Returns:
            Ok(User | None) - User model if found, None if not found
            Err(str) if database error
        """
        try:
            with DatabaseSessionManager.get_session() as session:
                user = session.query(User).filter_by(email=email).first()
                return Ok(user)
        except Exception as e:
            return Err(f"Database error: {str(e)}")

    def get_user(self, user_id: str) -> Result[User | None, str]:
        """Get a user record by ID.

        Args:
            user_id: The user ID to retrieve

        Returns:
            Ok(User | None) - User model if found, None if not found
            Err(str) if database error
        """
        try:
            with DatabaseSessionManager.get_session() as session:
                user = session.get(User, user_id)
                return Ok(user)
        except Exception as e:
            return Err(f"Database error: {str(e)}")
